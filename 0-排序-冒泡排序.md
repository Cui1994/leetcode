# 冒泡排序

## 思路

对于长度为n的数组，循环n-1次，每次循环进行数次冒泡，将未排序的数字中最大的数字放在数组靠后的位置，每次循环将确定[n-i]位置的元素。

可优化点：当一次循环中所有冒泡完成均无数字交换时，说明数组已处于有序状态，可提前结束。

## Code

```java
class Solution {

    public void bubleSort(int[] a) {
        int len = a.length;

        for (int i=0; i<len; i++) {
            boolean flag = false;

            for (int j=0; j<len-i-1; j++) {
                if (a[j] > a[j+1]) {
                    int tmp = a[j];
                    a[j] = a[j+1];
                    a[j+1] = tmp;
                    flag = true;
                }
            }

            if (flag) break;
        }
    }
}
```

## 复杂度分析

时间复杂度：

- 最好时间复杂度：数组已处于有序状态，只需要(n-1)次冒泡即可结束，时间复杂度为O(n)。
- 最坏时间复杂度：数组处于倒序状态，需要(n-1)次循环，时间复杂度为O(n^2)。

空间复杂度：

- 只存在元素交换，原地排序，空间复杂度为O(1)。

平均复杂度：O(n^2)

- 最大逆序度：n(n-1)/2
- 最小逆序度：0
- 平均逆序度：n(n-1)/4

## 稳定性分析

只有前方数字大于后方时才会交换，大小相等时不做交换，冒泡排序为稳定排序。
